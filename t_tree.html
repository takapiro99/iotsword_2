<!DOCTYPE html>
	<html lang="en">

	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<title>Tree｜みんなのツリー</title>
        <link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
		<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
		<script>
			const mycanvaswidth = 336; //canvasの横幅
			const mycanvasheight = 360; //canvasの高さ
			//できれば24の倍数で！なぜならマスが等間隔に並んできれいになるからー！
		</script>
	</head>

<body id="tree">

<div id=wraps>
<div id="wrap1">
<div id="inputs">
		  					
  <label class="control-label">mode</label>
  <btn type="button" id="pen-mode" class="btn page-link text-dark d-inline-block"><i class="fas fa-pencil-alt"></i></btn>
  <btn type="button" id="erase-mode" class="btn page-link text-dark d-inline-block"><i class="fas fa-eraser"></i></btn>
  <btn type="button" value="塗りつぶし" class="btn page-link text-dark d-inline-block" onclick="yamada()"><i class="fas fa-fill-drip"></i></btn><br>
  <label class="control-label">color<input type="color" class="color-picker" value="#6aa5b8" id="takeda"></label>
    <br>
  
    <input type="button" value="テンプレート１" class="btn page-link text-dark d-inline-block" onclick="template1()">
    <br>

  <input type="button" id="undo" value="1つ前の状態に戻す" class="btn page-link text-dark d-inline-block">
  <div class="sousin">
  <input type="button" id="clear" value="すべて消す" class="btn btn-outline-danger">
  <button onclick="colorinfos();execPost();return false;" class="btn btn-outline-success">送信</button>
  </div>
  </div>
  
    
  
<div id="canvas123">
 
    <canvas class="mycanvas" id="mycanvas">残念ながらHTML5に対応していません</canvas>
  <div class="dodai"></div>
</div>



</div>
  </div>
      
		<script>
			function quantize(xx, yy) {
				for (let i = 0; i < 12; i++) {
					if (eachheight * i < yy && yy < eachheight * (i + 1)) {
						let left = rowstart0[i] * eachwidthhalf;
						let width = eachwidthhalf * 2
						for (let j = 0; j < cells[i]; j++) {
							if (left < xx && xx < left + width) {
								return (sums[i] + j);
							}
							left += width;
						}
						break;
					}
				}
			}


			const mycanvas = document.getElementById('mycanvas');
			const c = mycanvas.getContext("2d");
			var eachheight = mycanvasheight / 12;
			var eachwidthhalf = mycanvaswidth / 24;

			var goright = [1, 1, 1, 1, 1, 1, 2, 1, 1, 4, 1, 1, 2, 1, 1, 1, 1, 1, 1];
			var goupdown = [-1, -2, -2, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1];

			var rows2 = [2, 3, 4, 6, 7, 8, 9, 10, 11, 12]; //partition は、これ-1.each
			var steps2 = [1, 1, 1, 1, 1, 1, 1, 2, 2, 1];
			var rowlength = [4, 6, 8, 12, 14, 16, 18, 20, 20, 22, 22];
			var rowstart = [10, 9, 8, 6, 5, 4, 3, 2, 1, 0];
			var rowstart0 = [10, 9, 8, 6, 5, 4, 3, 2, 2, 1, 1, 0];

			var cells = [2, 3, 4, 6, 7, 8, 9, 10, 10, 11, 11, 12];
			var sums = [0, 2, 5, 9, 15, 22, 30, 39, 49, 59, 70, 81];
			const mvr = 2;
			const mvd = 3;
			const cutr = 1;
			const cutd = 2;

			var colour = document.getElementById("takeda");


			//in every fill[i] there is a function to fill i'th cell.
			//you can call function like "fill[i](<whatevercolor>);" so i'th cell will filled with whatevercolor
			var fill = []
			for (let i = 0; i < 12; i++) {
				for (let j = 0; j < cells[i]; j++) {
					fill[sums[i] + j] = function (colour) {
						c.fillStyle = colour;
						c.strokeStyle = "black";
						c.beginPath();
						/*c.arc (rowstart0[i]*eachwidthhalf+j*eachwidthhalf*2+mvr+eachwidthhalf,
						                             eachheight*i+mvd,
						                        eachwidthhalf,
						                             0,Math.PI*2);*/
						c.arc(rowstart0[i] * eachwidthhalf + j * eachwidthhalf * 2 + mvr + eachwidthhalf, eachheight * i +
							mvd +
							eachheight / 2, eachwidthhalf * 0.7, 0, Math.PI * 2); //
						c.closePath();
						c.fill();
						//eachwidthhalf*2-cutr,
						//eachheight-cutd);
						console.log("filled" + String(sums[i] + j)); //for development
					};
				}
			};

			var colour = document.getElementById("takeda");

			document.getElementById("pen-mode").onclick = function () {
				colour.value = def_color;
			};

			document.getElementById("erase-mode").onclick = function () {
				def_color = colour.value;
				colour.value = "#ffffff";
			};
			//initialize the canvas so thus you cannot change size after.
			function init() {
				mycanvas.setAttribute('width', mycanvaswidth + 5);
				mycanvas.setAttribute('height', mycanvasheight + 5);
				//c.fillStyle = "black";
				//c.fill() ;
				//c.fillRect(0,0,mycanvaswidth,mycanvasheight);
				c.strokeStyle = "white";
				c.beginPath();
				//c.moveTo(1/2*mycanvaswidth,(-0.3)*mycanvasheight);
				//c.lineTo(mycanvaswidth,0);
				c.lineTo(mycanvaswidth, mycanvasheight);
				c.lineTo(0, mycanvasheight);
				c.closePath();
				//外形を見たいときは下のコメントアウトを外す
				c.stroke();
				//木の外側を書く
				var xx = 2;
				var yy = mycanvasheight + 2; //線がはみ出るの防止
				c.strokeStyle = "black";
				c.lineWidth = "1";
				c.beginPath();
				c.moveTo(xx, yy);
				c.lineCap = "round";
				for (let i = 0; i < 20; i++) {
					yy += eachheight * goupdown[i];
					c.lineTo(xx, yy);
					xx += eachwidthhalf * goright[i];
					c.lineTo(xx, yy)
				}
				c.closePath();
				c.stroke();
				c.fillStyle = "darkgreen";
				c.fill();

				c.fillStyle = "white";
				//丸の枠線かくとこ
				for (let i = 0; i < 12; i++) {
					for (let j = 0; j < cells[i]; j++) {


						c.strokeStyle = "rgba(0,0,0,0.2)";
						c.beginPath();
						/*c.arc (rowstart0[i]*eachwidthhalf+j*eachwidthhalf*2+mvr+eachwidthhalf,
						                             eachheight*i+mvd,
						                        eachwidthhalf,
						                             0,Math.PI*2);*/
						c.arc(rowstart0[i] * eachwidthhalf + j * eachwidthhalf * 2 + mvr + eachwidthhalf, eachheight * i + mvd +
							eachheight / 2, eachwidthhalf * 0.7 + 1, 0, Math.PI * 2); //
						c.closePath();
						c.stroke();
						//eachwidthhalf*2-cutr,
						//eachheight-cutd);
						//console.log("filled"+String(sums[i]+j)); //for developmentÏ

					};

				};
				for (var i = 0; i < 93; i++) {
					fill[i]("white")
				}
			}

			init();
		</script>


		<script>
			//script for mouse drawing, undo, and erase
			var mouse = {
				x: 0,
				y: 0,
				x1: 0,
				y1: 0
			};
			var draw = false;
			mycanvas.addEventListener("mousemove", function (e) {
				var rect = e.target.getBoundingClientRect();
				mouseX = e.clientX - rect.left;
				mouseY = e.clientY - rect.top;

				if (draw === true) {
					mouseX1 = mouseX;
					mouseY1 = mouseY;
					if (quantize(mouseX, mouseY) === undefined) {
						console.log("out of tree!!!!") //for test
					} else {
						fill[quantize(mouseX, mouseY)](colour.value);
					}
				}
			});
			mycanvas.addEventListener("mousedown", function (e) {
				draw = true;
				mouseX1 = mouseX;
				mouseY1 = mouseY;
				undoImage = c.getImageData(0, 0, mycanvas.width, mycanvas.height);
				if (quantize(mouseX, mouseY) === undefined) {
					console.log("out of tree!!!!") //for test
				} else {
					fill[quantize(mouseX, mouseY)](colour.value);
				}
			});
			mycanvas.addEventListener("mouseup", function (e) {
				draw = false;
			});
			window.addEventListener("mouseup", function (e) {
				draw = false;
			});
			$('#clear').click(function (e) {
				if (!confirm('本当に消去しますか？'))
					return;
				e.preventDefault();
				init();
			});
			$('#undo').click(function (e) {
				c.putImageData(undoImage, 0, 0);
			});
		</script>


		<script>

			//for smartphones
			var finger1 = {
				x: 0,
				y: 0,
				x1: 0,
				y1: 0
			}
			//get where touch started
			mycanvas.addEventListener("touchstart", function (e) {
				e.preventDefault();
				var rect = e.target.getBoundingClientRect();
				undoImage = c.getImageData(0, 0, mycanvas.width, mycanvas.height);
				finger1.x1 = e.touches[0].clientX - rect.left;
				finger1.y1 = e.touches[0].clientY - rect.top;
				if (quantize(finger1.x1, finger1.y1) === undefined) {
					console.log("out of tree!!!!") //for test
				} else {
					fill[quantize(finger1.x1, finger1.y1)](colour.value);
				}
			});
			//draw when move while touching
			mycanvas.addEventListener("touchmove", function (e) {
				e.preventDefault();
				var rect = e.target.getBoundingClientRect();
				finger1.x = e.touches[0].clientX - rect.left;
				finger1.y = e.touches[0].clientY - rect.top;
				finger1.x1 = finger1.x;
				finger1.y1 = finger1.y;
				if (quantize(finger1.x, finger1.y) === undefined) {
					console.log("out of tree! (touched)")
				} else {
					fill[quantize(finger1.x, finger1.y)](colour.value);
				}
			});
		</script>




		<script>
			//script for getting infos of the tree and send
			function rgb2hex(rgb) {
				return "#" + rgb.map(function (value) {
					return ("0" + value.toString(16)).slice(-2);
				}).join("").slice(0, -2);
			}


			//reads color each 6px from upperleft  
			function colorinfos() {
				colorinfo = [];
				for (let i = 0; i < 12; i++) {
					let xx = eachwidthhalf * rowstart0[i] + 14;
					for (let j = 0; j < cells[i]; j++) {
						//console.log(xx,(eachheight * i )+ 14 );
						let dd = c.getImageData(xx, (eachheight * i )+ 14 , 1, 1);
						let ddd = Array.from(dd.data);
						//console.log(xx,eachheight*i+6)
						xx += eachwidthhalf * 2;
						colorinfo.push(ddd);

					}
				}
				//console.log(colorinfo);
			}
		</script>
		<script>
			//script to post
			function execPost() {
				// フォームの生成
				form = document.getElementById("colorpost");
				form.style.display = "none";
				document.body.appendChild(form);
				// パラメタの設定
				for (var i in colorinfo) {
					set(i, colorinfo[i]);
				}
				set("name", document.getElementById("name").value);
				set("category", document.getElementById("category").value);
				console.log(form);
				// post
				form.submit();
			}

			function template1() {
				fill[0]("red");
			}

			function yamada() {
				for(var i=0; i < 93; i++){
					fill[i](document.getElementById("takeda").value);
				};
			}
		</script>
		








<style>


body {
  font-size: 15px;
  line-height: 2;
  margin: 100;
  padding: 0;
  color: #333333;
  text-align: center;
  font-family: Arial;
}



p,h1,h2,h3,h4,h5,h6 {
  margin:0px;
}



h1 {
  font-size: 36px;
}

h2 {
  font-size: 24px;
  color:white;
}

table {
  border-spacing: 0;
  border-collapse: collapse;
}


.clearfix:after {
  display: block;
  clear: both;
  content: "";
}


#tree{
  background-color:lightpink;
}


/*tree table
----------------------------------------*/
  .submit-button, .quick-fill, .erase-mode, .draw-mode {
    box-shadow: inset 0px 1px 0 0 #fff;
      background: linear-gradient(#f9f9f9 5%, #e9e9e9 100%);
    /* creates rounded edges (more pixels -> more rounded) */
      border-radius: 7px;
      border: 1px solid #dcdcdc;
      font-weight: bold;
    /* Padding is space between element's content and border. First value sets top and bottom padding; second value sets right and left */
      padding: 6px 24px;
      text-decoration: none;
      /* text-shadow: 0 1px #fff; */
    cursor: pointer;
    /* Places button on its own line */
    display: block;
    margin-top: 1em;
  }
  
  .color-picker {
    border: 1px solid #dcdcdc;
    -webkit-appearance: none;
    padding: 0;
    border-radius: 10px;
    width: 20px;
    height: 20px;
    cursor: pointer;
  }
  
  .color-picker::-webkit-color-swatch {
    border: none;
    border-radius: 10px;
    padding: 0;
  }
  .color-picker::-webkit-color-swatch-wrapper {
    border: none;
    border-radius: 10px;
    padding: 0;
  }


</style>


	
      </body>
  

</html>
	